#' Aggregate Progression Conditions
#'
#' @param progress A [progressor] function.
#'
#' @return A function of class `progress_aggregator`.
#'
#' @example incl/progress_aggregator.R
#'
#' @keywords internal
#' @export
progress_aggregator <- function(progress) {
  stop_if_not(inherits(progress, "progressor"))

  ## Here we can find out how many steps the progressor function wants
  max_steps <- environment(progress)$steps
  
  handler <- function(p) {
    stop_if_not(inherits(p, "progression"))
    type <- p$type
    debug <- getOption("progressr.debug", FALSE)
    if (debug) {
      mprintf("Progression handler %s ...", sQuote(type))
      on.exit(mprintf("Progression handler %s ... done", sQuote(type)))
      mprintf("- progression:")
      mstr(p)
      mprintf("- progressor_uuid: %s", p$progressor_uuid)
      mprintf("- progression_index: %d", p$progression_index)
    }
    if (type == "initiate") {
    } else if (type == "finish") {
    } else if (type == "reset") {
    } else if (type == "shutdown") {
    } else if (type == "update") {
      call_progressor_with_progression(progress, p)
    } else {
      ## Was this meant to be a 'control_progression' condition?
      if (type %in% c("reset", "shutdown", "hide", "unhide", "interrupt")) {
        stop("Unsupported 'progression' type. Was it meant to be a 'control_progression' condition?: ", sQuote(type))
      } else {
        stop("Unknown 'progression' type: ", sQuote(type))
      }
    }
    
    ## Prevent upstream calling handlers to receive progression 'p'
    invokeRestart("muffleProgression")
  }

  handler <- make_progression_handler("progress_aggregator", handler = handler)
  
  fcn <- function(...) {
    with_progress(..., handlers = handler)
  }
  class(fcn) <- c("progress_aggregator", class(fcn))

  fcn
}

#' Rewrite a progression condition and emit using another progressor
#' 
#' The progression condition `prog_cnd` is disassembled, the properties that are
#' set by the original progressor are removed and the progression is re-created
#' using the progressor `progr`.
#' 
call_progressor_with_progression <- function(progr, prog_cond){
  c <- setdiff(class(prog_cond), c("progression", "immediateCondition", "condition"))
  arg_list <- unclass(prog_cond)
  # Remove all arguments from the list that are not included by the progressor
  # (the function generated by a call to the progressor() function) into the 
  # resulting condition object but are set by the progressor itself. See
  # the function that is the return value of progressor() for those arguments.
  arg_list$owner_session_uuid <- NULL
  arg_list$progressor_uuid    <- NULL
  arg_list$progression_index  <- NULL
  arg_list$call               <- NULL
  arg_list$calls              <- NULL
  do.call(progr, arg_list)
}
